/*HEADER**********************************************************************
*
* Copyright 2014 Freescale Semiconductor, Inc.
*
* This software is owned or controlled by Freescale Semiconductor.
* Use of this software is governed by the Freescale MQX RTOS License
* distributed with this Material.
* See the MQX_RTOS_LICENSE file distributed for more details.
*
* Brief License Summary:
* This software is provided in source form for you to use free of charge,
* but it is not open source software. You are allowed to use this software
* but you cannot redistribute it or derivative works of it in source form.
* The software may be used only in connection with a product containing
* a Freescale microprocessor, microcontroller, or digital signal processor.
* See license agreement file for full license terms including other
* restrictions.
*****************************************************************************
*
* Comments:
*   Clock manager Kinetis BSP specific definitions and function prototypes.
*
*       _bsp_initialize_hardware();
*       _bsp_set_clock_configuration();
*       _bsp_get_clock_configuration();
*       _bsp_get_clock();
*       _bsp_osc_autotrim();
*
*END************************************************************************/

#include <mqx.h>
#include <bsp.h>
#include <bsp_prv.h>


#ifdef PE_LDD_VERSION

extern const TCpuClockConfiguration PE_CpuClockConfigurations[CPU_CLOCK_CONFIG_NUMBER];

#else /* PE_LDD_VERSION */


/* Clock Manager Errors  */
#define ERR_OK          CM_ERR_OK               /* OK */
#define ERR_SPEED       CM_ERR_SPEED            /* This device does not work in the active speed mode. */
#define ERR_RANGE       CM_ERR_RANGE            /* Parameter out of range. */
#define ERR_VALUE       CM_ERR_VALUE            /* Parameter of incorrect value. */
#define ERR_FAILED      CM_ERR_FAILED           /* Requested functionality or process failed. */
#define ERR_PARAM_MODE  CM_ERR_PARAM_MODE       /* Invalid mode. */


#define PE_WFI()        _ASM_WFI()

/* The following code is copied from the code generated by Processor Expert */

/*
** ===================================================================
** Global HAL types and constants
** ===================================================================
*/
typedef uint32_t LDD_TPinMask;         /*!< Pin mask type. */
typedef uint16_t LDD_TError;           /*!< Error type. */
typedef uint32_t LDD_TEventMask;       /*!< Event mask type. */
typedef uint8_t LDD_TClockConfiguration; /*!< CPU clock configuration type. */
typedef void LDD_TDeviceData;          /*!< Pointer to private device structure managed and used by HAL components. */
typedef void* LDD_TDeviceDataPtr;      /*!< Obsolete type for backward compatibility. */
typedef void LDD_TData;                /*!< General pointer to data. */
typedef void LDD_TUserData;            /*!< Pointer to this type specifies the user or RTOS specific data will be passed as an event or callback parameter. */

/*! Driver operation mode type. */
typedef enum {
  DOM_NONE,
  DOM_RUN,
  DOM_WAIT,
  DOM_SLEEP,
  DOM_STOP
} LDD_TDriverOperationMode;

typedef uint16_t LDD_TDriverState;     /*!< Driver state type. */
typedef void LDD_TCallbackParam;       /*!< Pointer to this type specifies the user data to be passed as a callback parameter. */
typedef void (* LDD_TCallback)(LDD_TCallbackParam *CallbackParam); /*!< Callback type used for definition of callback functions. */

extern LDD_TDeviceData *PE_LDD_DeviceDataList[]; /*!< Array of LDD component device structures */

/* MCG mode and clock source features - used to fill CPU_TClockGenMode and CPU_TClockSource */
#define CPU_CLOCK_SLOW_MASK                                0x10U     /* Mode uses slow internal reference clock */ 
#define CPU_CLOCK_FAST_MASK                                0x20U     /* Mode uses fast internal reference clock */ 
#define CPU_CLOCK_EXTERNAL_CLOCK_MASK                      0x40U     /* Mode uses external reference clock from external clock input */ 
#define CPU_CLOCK_EXTERNAL_CRYSTAL_MASK                    0x80U     /* Mode uses external reference clock from crystal/resonator reference connection */ 
#define CPU_CLOCK_RTC_OSC_MASK                             0x0100U   /* Mode uses RTC oscillator clock */ 
#define CPU_CLOCK_PLL_MASK                                 0x0200U   /* PLL module is enabled in other than PEE and PBE mode */ 

/* MCG mode IDs - used to fill CPU_TClockGenMode */
#define CPU_MCG_MODE_FEI                                   0x00U     /* FEI mode ID */ 
#define CPU_MCG_MODE_FBI                                   0x01U     /* FBI mode ID */ 
#define CPU_MCG_MODE_BLPI                                  0x02U     /* BLPI mode ID */ 
#define CPU_MCG_MODE_FEE                                   0x03U     /* FEE mode ID */ 
#define CPU_MCG_MODE_FBE                                   0x04U     /* FBE mode ID */ 
#define CPU_MCG_MODE_BLPE                                  0x05U     /* BLPE mode ID */ 
#define CPU_MCG_MODE_PBE                                   0x06U     /* PBE mode ID */ 
#define CPU_MCG_MODE_PEE                                   0x07U     /* PEE mode ID */ 
#define CPU_MCG_MODES                                      0x08U     /* Number of available MCG modes */ 
#define CPU_MCG_MODE_INDEX_MASK                            0x0FU     /* Mask of bits where MCG mode ID is encoded */ 

/* MCG mode type - used to specify MCG mode of each Clock configuration */
typedef uint16_t CPU_TClockGenMode;

/* 
    Very low power mode constants
    
    Constants used to specify very low power mode settings in each
    clock configuration.
*/

/* Low power mode settings mask constants - used to fill CPU_TClockVeryLowPower */
#define CPU_CLOCK_VLP_ENABLE_MASK                          0x01U     /* Very low power mode enabled */ 
#define CPU_CLOCK_VLP_AUTO_ENABLE_MASK                     0x02U     /* Very low power mode entered automatically from SetClockConfiguration method */ 
#define CPU_CLOCK_VLP_WAKEUP_MASK                          0x04U     /* Very low power mode exited after any interrupt */ 

/* Low power mode settings type - used to enable/set-up Very low power mode of each Clock configuration */
typedef uint8_t CPU_TClockVeryLowPower;

/* 
    Clock configuration descriptor
    
    Following types are used to define and store settings related to
    clock generator modules (i.e. MCG and OSC modules), system or common clock 
    dividers and selectors (SIM module) for each predefined Clock configuration. 
    When Clock configuration is switched the processor registers are updated 
    from the following descriptors.
*/

/* MCG and OSC module structure type
   Structure with MCG and OSC configuration. To lower memory footprint the structure 
   doesn't contain full list of MCG and OSC registers but only those with settings 
   necessary to set Clock configuration. */
typedef struct {
  uint8_t MCG_C1_value;
  uint8_t MCG_C2_value;
  uint8_t MCG_C4_value;
  uint8_t MCG_C5_value;
  uint8_t MCG_C6_value;
  uint8_t MCG_SC_value;
  uint8_t OSC_CR_value;
} CPU_TClockGenRegs;

/* Clock system settings structure type
   Structure contains system integration level clock settings - clock source 
   selectors and dividers which control clocks produced by MCG and OSC modules and 
   peripheral clock source selections common for multiple peripheral instances. */
typedef struct {
  uint32_t SIM_SOPT1_value;
  uint32_t SIM_SOPT2_value;
  uint32_t SIM_CLKDIV1_value;
} CPU_TClockSysRegs;

/* Clock configuration descriptor structure type 
   Gathers all Clock configuration settings. Content of this structure is used 
   during Clock configuration set up. */
typedef struct {
  CPU_TClockGenMode Mode;
  CPU_TClockVeryLowPower LowPower;
  CPU_TClockGenRegs GenRegs;
  CPU_TClockSysRegs SysRegs;
  uint32_t BusClock;
} CPU_TClockConfigDescriptor;

/* Clock configuration structure content
   
   Following constants are use to initialize CPU_TClockConfigDescriptor structure
   in the static CPU_Init.c module. Constants for each Clock configuration
   enabled in the processor (CPU) component are generated.

   Properties: Clock settings\Clock configurations,
               Clock settings\Clock source settings,
               Clock settings\Clock sources.
*/

/* Clock configuration 0 */
#define CPU_MCG_MODE_CONFIG_0                              (CPU_MCG_MODE_PEE | CPU_CLOCK_EXTERNAL_CLOCK_MASK | CPU_CLOCK_FAST_MASK) /* Clock generator mode */
#define CPU_CLOCK_VLP_CONFIG_0                             0U /* Very low power mode disabled */
#define CPU_MCG_C1_CONFIG_0                                0x28U /* MCG_C1 */
#define CPU_MCG_C2_CONFIG_0                                0x21U /* MCG_C2 */
#define CPU_MCG_C4_CONFIG_0                                0x00U /* MCG_C4 */
#define CPU_MCG_C5_CONFIG_0                                0x13U /* MCG_C5 */
#define CPU_MCG_C6_CONFIG_0                                0x58U /* MCG_C6 */
#define CPU_MCG_SC_CONFIG_0                                0x02U /* MCG_SC */
#define CPU_OSC_CR_CONFIG_0                                0x80U /* OSC_CR */
#define CPU_SIM_SOPT1_CONFIG_0                             0x00080000UL /* SIM_SOPT1 */
#define CPU_SIM_SOPT2_CONFIG_0                             0x00010000UL /* SIM_SOPT2 */
#define CPU_SIM_CLKDIV1_CONFIG_0                           0x01240000UL /* SIM_CLKDIV1 */
/* Clock configuration 1 */
#define CPU_MCG_MODE_CONFIG_1                              (CPU_MCG_MODE_PEE | CPU_CLOCK_EXTERNAL_CLOCK_MASK | CPU_CLOCK_FAST_MASK) /* Clock generator mode */
#define CPU_CLOCK_VLP_CONFIG_1                             0U /* Very low power mode disabled */
#define CPU_MCG_C1_CONFIG_1                                0x28U /* MCG_C1 */
#define CPU_MCG_C2_CONFIG_1                                0x21U /* MCG_C2 */
#define CPU_MCG_C4_CONFIG_1                                0x00U /* MCG_C4 */
#define CPU_MCG_C5_CONFIG_1                                0x13U /* MCG_C5 */
#define CPU_MCG_C6_CONFIG_1                                0x58U /* MCG_C6 */
#define CPU_MCG_SC_CONFIG_1                                0x02U /* MCG_SC */
#define CPU_OSC_CR_CONFIG_1                                0x80U /* OSC_CR */
#define CPU_SIM_SOPT1_CONFIG_1                             0x00080000UL /* SIM_SOPT1 */
#define CPU_SIM_SOPT2_CONFIG_1                             0x00010000UL /* SIM_SOPT2 */
#define CPU_SIM_CLKDIV1_CONFIG_1                           0x99990000UL /* SIM_CLKDIV1 */
/* Clock configuration 2 */
#define CPU_MCG_MODE_CONFIG_2                              (CPU_MCG_MODE_BLPI | CPU_CLOCK_FAST_MASK) /* Clock generator mode */
#define CPU_CLOCK_VLP_CONFIG_2                             0U /* Very low power mode disabled */
#define CPU_MCG_C1_CONFIG_2                                0x46U /* MCG_C1 */
#define CPU_MCG_C2_CONFIG_2                                0x23U /* MCG_C2 */
#define CPU_MCG_C4_CONFIG_2                                0x00U /* MCG_C4 */
#define CPU_MCG_C5_CONFIG_2                                0x00U /* MCG_C5 */
#define CPU_MCG_C6_CONFIG_2                                0x00U /* MCG_C6 */
#define CPU_MCG_SC_CONFIG_2                                0x02U /* MCG_SC */
#define CPU_OSC_CR_CONFIG_2                                0x00U /* OSC_CR */
#define CPU_SIM_SOPT1_CONFIG_2                             0x00080000UL /* SIM_SOPT1 */
#define CPU_SIM_SOPT2_CONFIG_2                             0x00UL /* SIM_SOPT2 */
#define CPU_SIM_CLKDIV1_CONFIG_2                           0x00030000UL /* SIM_CLKDIV1 */

/* 
   Clock generator structure default content
   
   When Clock configurations set in the processor (CPU) component use different MCG 
   modes and transition between them requires passing through some intermediate MCG 
   mode then following constants are used to set up clock generator modules to these 
   intermediate MCG modes. Following constants represent CPU_TClockGenRegs structure 
   content loaded to the clock generator registers to configure the intermediate 
   mode of the generator modules.
   
   If setting is controlled by any property then the associated property is specified. 
   Rest of settings are not controlled by any property and their value is static.
*/


/* Clock generator default state in FEI mode 
   Clock source:                        Slow internal reference, disabled in the STOP mode
   Clock source frequency:              32.768 kHz (Property: Clock settings\Clock sources\Internal oscillator\Slow internal reference clock)
   FLL:                                 Enabled, engaged
   FLL factor:                          640
   Internal reference clock (MCGIRCLK): Disabled
   External reference clock (OSCERCLK): Disabled
   External clock monitor:              Disabled
   Loss of clock reset:                 Enabled
*/
/* MCG_C1: CLKS=0,IREFS=1,IRCLKEN=0,IREFSTEN=0 */
#define CPU_DEFAULT_FEI_MCG_C1                             0x04U     /* MCG_C1 value in FEI default state */ 
/* MCG_C2: LOCRE0=1 */
#define CPU_DEFAULT_FEI_MCG_C2                             0x80U     /* MCG_C2 value in FEI default state */ 
/* MCG_C4: DMX32=0,DRST_DRS=0 */
#define CPU_DEFAULT_FEI_MCG_C4                             0x00U     /* MCG_C4 value in FEI default state */ 
/* MCG_C5: PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
#define CPU_DEFAULT_FEI_MCG_C5                             0x00U     /* MCG_C5 value in FEI default state */ 
/* MCG_C6: LOLIE0=0,CME0=0,VDIV0=0 */
#define CPU_DEFAULT_FEI_MCG_C6                             0x00U     /* MCG_C6 value in FEI default state */ 
/* MCG_C6: VDIV0|=2 */
#define CPU_DEFAULT_FEI_MCG_SC                             0x02U     /* MCG_SC value in FEI default state */ 
/* OSC_CR: ERCLKEN=0,EREFSTEN=0 */
#define CPU_DEFAULT_FEI_OSC_CR                             0x00U     /* OSC_CR value in FEI default state */ 

/* Clock generator default state in FBI mode
   Clock source:                        Slow internal reference, disabled in the STOP mode
   Clock source frequency:              32.768 kHz (Property: Clock settings\Clock sources\Internal oscillator\Slow internal reference clock)
   FLL:                                 Enabled, bypassed
   FLL factor:                          640
   Internal reference clock (MCGIRCLK): Disabled
   External reference clock (OSCERCLK): Disabled
   External clock monitor:              Disabled
   Loss of clock reset:                 Enabled
*/
/* MCG_C1: CLKS|=1,IREFS=1,IRCLKEN=0,IREFSTEN=0 */
#define CPU_DEFAULT_FBI_MCG_C1                             0x44U     /* MCG_C1 value in FBI default state */ 
/* MCG_C2: LOCRE0=1 */
#define CPU_DEFAULT_FBI_MCG_C2                             0x80U     /* MCG_C2 value in FBI default state */ 
/* MCG_C4: DMX32=0,DRST_DRS=0 */
#define CPU_DEFAULT_FBI_MCG_C4                             0x00U     /* MCG_C4 value in FBI default state */ 
/* MCG_C5: PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
#define CPU_DEFAULT_FBI_MCG_C5                             0x00U     /* MCG_C5 value in FBI default state */ 
/* MCG_C6: LOLIE0=0,CME0=0,VDIV0=0 */
#define CPU_DEFAULT_FBI_MCG_C6                             0x00U     /* MCG_C6 value in FBI default state */ 
/* MCG_C6: VDIV0|=2 */
#define CPU_DEFAULT_FBI_MCG_SC                             0x02U     /* MCG_SC value in FBI default state */ 
/* OSC_CR: ERCLKEN=0,EREFSTEN=0 */
#define CPU_DEFAULT_FBI_OSC_CR                             0x00U     /* OSC_CR value in FBI default state */ 

/* Clock generator default state in BLPI mode
   Clock source:                        Slow internal reference, disabled in the STOP mode
   Clock source frequency:              32.768 kHz (Property: Clock settings\Clock sources\Internal oscillator\Slow internal reference clock)
   FLL:                                 Disabled
   Internal reference clock (MCGIRCLK): Disabled
   External reference clock (OSCERCLK): Disabled
   External clock monitor:              Disabled
   Loss of clock reset:                 Enabled
*/
/* MCG_C1: CLKS|=1,IREFS=1,IRCLKEN=0,IREFSTEN=0 */
#define CPU_DEFAULT_BLPI_MCG_C1                            0x44U     /* MCG_C1 value in BLPI default state */ 
/* MCG_C2: LOCRE0=1,LP=1 */
#define CPU_DEFAULT_BLPI_MCG_C2                            0x82U     /* MCG_C2 value in BLPI default state */ 
/* MCG_C4:  */
#define CPU_DEFAULT_BLPI_MCG_C4                            0x00U     /* MCG_C4 value in BLPI default state */ 
/* MCG_C5: PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
#define CPU_DEFAULT_BLPI_MCG_C5                            0x00U     /* MCG_C5 value in BLPI default state */ 
/* MCG_C6: LOLIE0=0,CME0=0,VDIV0=0 */
#define CPU_DEFAULT_BLPI_MCG_C6                            0x00U     /* MCG_C6 value in BLPI default state */ 
/* MCG_C6: VDIV0|=2 */
#define CPU_DEFAULT_BLPI_MCG_SC                            0x02U     /* MCG_SC value in BLPI default state */ 
/* OSC_CR: ERCLKEN=0,EREFSTEN=0 */
#define CPU_DEFAULT_BLPI_OSC_CR                            0x00U     /* OSC_CR value in BLPI default state */ 

/* Clock generator default state in FEE mode
   Clock source:                        External reference clock (Property: Clock settings\Clock sources\System oscillator 0\Clock source)
   Clock source frequency:              50 MHz (Property: Clock settings\Clock sources\System oscillator 0\Clock source\Clock frequency)
   External frequency range:            Very high
   FLL external reference divider:      1280
   FLL:                                 Enabled, engaged
   FLL factor:                          640
   Internal reference clock (MCGIRCLK): Disabled
   External reference clock (OSCERCLK): Disabled
   External clock monitor:              Disabled
   Loss of clock reset:                 Enabled
*/
/* MCG_C1: CLKS=0,FRDIV|=6,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
#define CPU_DEFAULT_FEE_MCG_C1                             0x30U     /* MCG_C1 value in FEE default state */ 
/* MCG_C2: LOCRE0=1,RANGE0|=2 */
#define CPU_DEFAULT_FEE_MCG_C2                             0xA0U     /* MCG_C2 value in FEE default state */ 
/* MCG_C4: DMX32=0,DRST_DRS=0 */
#define CPU_DEFAULT_FEE_MCG_C4                             0x00U     /* MCG_C4 value in FEE default state */ 
/* MCG_C5: PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
#define CPU_DEFAULT_FEE_MCG_C5                             0x00U     /* MCG_C5 value in FEE default state */ 
/* MCG_C6: LOLIE0=0,CME0=0,VDIV0=0 */
#define CPU_DEFAULT_FEE_MCG_C6                             0x00U     /* MCG_C6 value in FEE default state */ 
/* MCG_C6: VDIV0|=2 */
#define CPU_DEFAULT_FEE_MCG_SC                             0x02U     /* MCG_SC value in FEE default state */ 
/* OSC_CR: ERCLKEN=0,EREFSTEN=0 */
#define CPU_DEFAULT_FEE_OSC_CR                             0x00U     /* OSC_CR value in FEE default state */ 

/* Clock generator default state in FBE mode
   Clock source:                        External reference clock (Property: Clock settings\Clock sources\System oscillator 0\Clock source)
   Clock source frequency:              50 MHz (Property: Clock settings\Clock sources\System oscillator 0\Clock source\Clock frequency)
   External frequency range:            Very high
   FLL external reference divider:      1280
   FLL:                                 Enabled, bypassed
   FLL factor:                          640
   Internal reference clock (MCGIRCLK): Disabled
   External reference clock (OSCERCLK): Disabled
   External clock monitor:              Disabled
   Loss of clock reset:                 Enabled
*/
/* MCG_C1: CLKS|=2,FRDIV|=6,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
#define CPU_DEFAULT_FBE_MCG_C1                             0xB0U     /* MCG_C1 value in FBE default state */ 
/* MCG_C2: LOCRE0=1,RANGE0|=2 */
#define CPU_DEFAULT_FBE_MCG_C2                             0xA0U     /* MCG_C2 value in FBE default state */ 
/* MCG_C4: DMX32=0,DRST_DRS=0 */
#define CPU_DEFAULT_FBE_MCG_C4                             0x00U     /* MCG_C4 value in FBE default state */ 
/* MCG_C5: PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
#define CPU_DEFAULT_FBE_MCG_C5                             0x00U     /* MCG_C5 value in FBE default state */ 
/* MCG_C6: LOLIE0=0,CME0=0,VDIV0=0 */
#define CPU_DEFAULT_FBE_MCG_C6                             0x00U     /* MCG_C6 value in FBE default state */ 
/* MCG_C6: VDIV0|=2 */
#define CPU_DEFAULT_FBE_MCG_SC                             0x02U     /* MCG_SC value in FBE default state */ 
/* OSC_CR: ERCLKEN=0,EREFSTEN=0 */
#define CPU_DEFAULT_FBE_OSC_CR                             0x00U     /* OSC_CR value in FBE default state */ 

/* Clock generator default state in BLPE mode
   Clock source:                        External reference clock (Property: Clock settings\Clock sources\System oscillator 0\Clock source)
   Clock source frequency:              50 MHz (Property: Clock settings\Clock sources\System oscillator 0\Clock source\Clock frequency)
   External frequency range:            Very high
   FLL external reference divider:      1280
   FLL:                                 Disabled
   Internal reference clock (MCGIRCLK): Disabled
   External reference clock (OSCERCLK): Disabled
   External clock monitor:              Disabled
   Loss of clock reset:                 Enabled
*/
/* MCG_C1: CLKS|=1,FRDIV|=6,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
#define CPU_DEFAULT_BLPE_MCG_C1                            0x70U     /* MCG_C1 value in BLPE default state */ 
/* MCG_C2: LOCRE0=1,RANGE0|=2,LP=1 */
#define CPU_DEFAULT_BLPE_MCG_C2                            0xA2U     /* MCG_C2 value in BLPE default state */ 
/* MCG_C4:  */
#define CPU_DEFAULT_BLPE_MCG_C4                            0x00U     /* MCG_C4 value in BLPE default state */ 
/* MCG_C5: PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
#define CPU_DEFAULT_BLPE_MCG_C5                            0x00U     /* MCG_C5 value in BLPE default state */ 
/* MCG_C6: LOLIE0=0,CME0=0,VDIV0=0 */
#define CPU_DEFAULT_BLPE_MCG_C6                            0x00U     /* MCG_C6 value in BLPE default state */ 
/* MCG_C6: VDIV0|=2 */
#define CPU_DEFAULT_BLPE_MCG_SC                            0x02U     /* MCG_SC value in BLPE default state */ 
/* OSC_CR: ERCLKEN=0,EREFSTEN=0 */
#define CPU_DEFAULT_BLPE_OSC_CR                            0x00U     /* OSC_CR value in BLPE default state */ 
/* Clock generator default state in PEE mode
   Clock source:                        External reference clock (Property: Clock settings\Clock sources\System oscillator 0\Clock source)
   Clock source frequency:              50 MHz (Property: Clock settings\Clock sources\System oscillator 0\Clock source\Clock frequency)
         PLL External Reference Divider       %EXPE(12 + 1)
         PLL Multiplier                       48
   PLL:                                 Enabled, engaged
   Internal reference clock (MCGIRCLK): Disabled
   External reference clock (OSCERCLK): Disabled
   External clock monitor:              Disabled
   Loss of clock reset:                 Enabled
*/
/* MCG_C1: CLKS=0,FRDIV|=6,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
#define CPU_DEFAULT_PEE_MCG_C1                             0x30U     /* MCG_C1 value in PEE default state */ 
/* MCG_C2: LOCRE0=1,RANGE0|=2 */
#define CPU_DEFAULT_PEE_MCG_C2                             0xA0U     /* MCG_C2 value in PEE default state */ 
/* MCG_C4: DMX32=0,DRST_DRS=0 */
#define CPU_DEFAULT_PEE_MCG_C4                             0x00U     /* MCG_C4 value in PEE default state */ 
/* MCG_C5: PLLCLKEN0=0,PLLSTEN0=0,PRDIV0|=0x0C */
#define CPU_DEFAULT_PEE_MCG_C5                             0x0CU     /* MCG_C5 value in PEE default state */ 
/* MCG_C6: PLLS=1,CME0=0,VDIV0|=0x18 */
#define CPU_DEFAULT_PEE_MCG_C6                             0x58U     /* MCG_C6 value in PEE default state */ 
/* MCG_C6: VDIV0|=2 */
#define CPU_DEFAULT_PEE_MCG_SC                             0x02U     /* MCG_SC value in PEE default state */ 
/* OSC_CR: ERCLKEN=0,EREFSTEN=0 */
#define CPU_DEFAULT_PEE_OSC_CR                             0x00U     /* OSC_CR value in PEE default state */ 
/* Clock generator default state in PBE mode
   Clock source:                        External reference clock (Property: Clock settings\Clock sources\System oscillator 0\Clock source)
   Clock source frequency:              50 MHz (Property: Clock settings\Clock sources\System oscillator 0\Clock source\Clock frequency)
         PLL External Reference Divider       %EXPE(12 + 1)
         PLL Multiplier                       48
   PLL:                                 Enabled, bypassed
   Internal reference clock (MCGIRCLK): Disabled
   External reference clock (OSCERCLK): Disabled
   External clock monitor:              Disabled
   Loss of clock reset:                 Enabled
*/
/* MCG_C1: CLKS|=2,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
#define CPU_DEFAULT_PBE_MCG_C1                             0x80U     /* MCG_C1 value in PBE default state */ 
/* MCG_C2: LOCRE0=1,RANGE0|=2 */
#define CPU_DEFAULT_PBE_MCG_C2                             0xA0U     /* MCG_C2 value in PBE default state */ 
/* MCG_C4: DMX32=0,DRST_DRS=0 */
#define CPU_DEFAULT_PBE_MCG_C4                             0x00U     /* MCG_C4 value in PBE default state */ 
/* MCG_C5: PLLCLKEN0=0,PLLSTEN0=0,PRDIV0|=0x0C */
#define CPU_DEFAULT_PBE_MCG_C5                             0x0CU     /* MCG_C5 value in PBE default state */ 
/* MCG_C6: PLLS=1,CME0=0,VDIV0|=0x18 */
#define CPU_DEFAULT_PBE_MCG_C6                             0x58U     /* MCG_C6 value in PBE default state */ 
/* MCG_C6: VDIV0|=2 */
#define CPU_DEFAULT_PBE_MCG_SC                             0x02U     /* MCG_SC value in PBE default state */ 
/* OSC_CR: ERCLKEN=0,EREFSTEN=0 */
#define CPU_DEFAULT_PBE_OSC_CR                             0x00U     /* OSC_CR value in PBE default state */ 


static const CPU_TClockGenMode ClockGenModeMatrix[8][8] = {
/* This matrix defines which mode is next in the MCG Mode state diagram in transitioning from the
   current mode to a target mode*/
  { CPU_MCG_MODE_FEI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FEE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE  }, /* FEI */
  { CPU_MCG_MODE_FEI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_BLPI, CPU_MCG_MODE_FEE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE  }, /* FBI */
  { CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_BLPI, CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FBI  }, /* BLPI */
  { CPU_MCG_MODE_FEI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FEE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE  }, /* FEE */
  { CPU_MCG_MODE_FEI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FBI,  CPU_MCG_MODE_FEE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_BLPE, CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PBE  }, /* FBE */
  { CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_BLPE, CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PBE  }, /* BLPE */
  { CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_FBE,  CPU_MCG_MODE_BLPE, CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PEE  }, /* PBE */
  { CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PBE,  CPU_MCG_MODE_PEE  }  /* PEE */
};

static const CPU_TClockConfigDescriptor CPU_ClockConfigDescriptors[CPU_CLOCK_CONFIG_NUMBER] = {
  #if defined(CPU_CLOCK_CONFIG_0)
  /* Clock configuration 0 */
  {
    CPU_MCG_MODE_CONFIG_0,             /* Clock generator mode */
    CPU_CLOCK_VLP_CONFIG_0,            /* Very low power mode enable/disable */
    {                                  /* MCG registers */
      CPU_MCG_C1_CONFIG_0,CPU_MCG_C2_CONFIG_0,CPU_MCG_C4_CONFIG_0,CPU_MCG_C5_CONFIG_0,CPU_MCG_C6_CONFIG_0,CPU_MCG_SC_CONFIG_0,CPU_OSC_CR_CONFIG_0,
    },
    {                                  /* SIM registers */
      CPU_SIM_SOPT1_CONFIG_0,CPU_SIM_SOPT2_CONFIG_0,CPU_SIM_CLKDIV1_CONFIG_0,
    },
    CPU_BUS_CLK_HZ_CONFIG_0            /* Bus frequency */
  }
  #endif
  #if defined(CPU_CLOCK_CONFIG_1)
  /* Clock configuration 1 */
  ,{
    CPU_MCG_MODE_CONFIG_1,             /* Clock generator mode */
    CPU_CLOCK_VLP_CONFIG_1,            /* Very low power mode enable/disable */
    {                                  /* MCG registers */
      CPU_MCG_C1_CONFIG_1,CPU_MCG_C2_CONFIG_1,CPU_MCG_C4_CONFIG_1,CPU_MCG_C5_CONFIG_1,CPU_MCG_C6_CONFIG_1,CPU_MCG_SC_CONFIG_1,CPU_OSC_CR_CONFIG_1,
    },
    {                                  /* SIM registers */
      CPU_SIM_SOPT1_CONFIG_1,CPU_SIM_SOPT2_CONFIG_1,CPU_SIM_CLKDIV1_CONFIG_1,
    },
    CPU_BUS_CLK_HZ_CONFIG_1            /* Bus frequency */
  }
  #endif
  #if defined(CPU_CLOCK_CONFIG_2)
  /* Clock configuration 2 */
  ,{
    CPU_MCG_MODE_CONFIG_2,             /* Clock generator mode */
    CPU_CLOCK_VLP_CONFIG_2,            /* Very low power mode enable/disable */
    {                                  /* MCG registers */
      CPU_MCG_C1_CONFIG_2,CPU_MCG_C2_CONFIG_2,CPU_MCG_C4_CONFIG_2,CPU_MCG_C5_CONFIG_2,CPU_MCG_C6_CONFIG_2,CPU_MCG_SC_CONFIG_2,CPU_OSC_CR_CONFIG_2,
    },
    {                                  /* SIM registers */
      CPU_SIM_SOPT1_CONFIG_2,CPU_SIM_SOPT2_CONFIG_2,CPU_SIM_CLKDIV1_CONFIG_2,
    },
    CPU_BUS_CLK_HZ_CONFIG_2            /* Bus frequency */
  }
  #endif
  #if defined(CPU_CLOCK_CONFIG_3)
  /* Clock configuration 3 */
  ,{
    CPU_MCG_MODE_CONFIG_3,             /* Clock generator mode */
    CPU_CLOCK_VLP_CONFIG_3,            /* Very low power mode enable/disable */
    {                                  /* MCG registers */
      CPU_MCG_C1_CONFIG_3,CPU_MCG_C2_CONFIG_3,CPU_MCG_C4_CONFIG_3,CPU_MCG_C5_CONFIG_3,CPU_MCG_C6_CONFIG_3,CPU_MCG_SC_CONFIG_3,CPU_OSC_CR_CONFIG_3,
    },
    {                                  /* SIM registers */
      CPU_SIM_SOPT1_CONFIG_3,CPU_SIM_SOPT2_CONFIG_3,CPU_SIM_CLKDIV1_CONFIG_3,
    },
    CPU_BUS_CLK_HZ_CONFIG_3            /* Bus frequency */
  }
  #endif
  #if defined(CPU_CLOCK_CONFIG_4)
  /* Clock configuration 4 */
  ,{
    CPU_MCG_MODE_CONFIG_4,             /* Clock generator mode */
    CPU_CLOCK_VLP_CONFIG_4,            /* Very low power mode enable/disable */
    {                                  /* MCG registers */
      CPU_MCG_C1_CONFIG_4,CPU_MCG_C2_CONFIG_4,CPU_MCG_C4_CONFIG_4,CPU_MCG_C5_CONFIG_4,CPU_MCG_C6_CONFIG_4,CPU_MCG_SC_CONFIG_4,CPU_OSC_CR_CONFIG_4,
    },
    {                                  /* SIM registers */
      CPU_SIM_SOPT1_CONFIG_4,CPU_SIM_SOPT2_CONFIG_4,CPU_SIM_CLKDIV1_CONFIG_4,
    },
    CPU_BUS_CLK_HZ_CONFIG_4            /* Bus frequency */
  }
  #endif
  #if defined(CPU_CLOCK_CONFIG_5)
  /* Clock configuration 5 */
  ,{
    CPU_MCG_MODE_CONFIG_5,             /* Clock generator mode */
    CPU_CLOCK_VLP_CONFIG_5,            /* Very low power mode enable/disable */
    {                                  /* MCG registers */
      CPU_MCG_C1_CONFIG_5,CPU_MCG_C2_CONFIG_5,CPU_MCG_C4_CONFIG_5,CPU_MCG_C5_CONFIG_5,CPU_MCG_C6_CONFIG_5,CPU_MCG_SC_CONFIG_5,CPU_OSC_CR_CONFIG_5,
    },
    {                                  /* SIM registers */
      CPU_SIM_SOPT1_CONFIG_5,CPU_SIM_SOPT2_CONFIG_5,CPU_SIM_CLKDIV1_CONFIG_5,
    },
    CPU_BUS_CLK_HZ_CONFIG_5            /* Bus frequency */
  }
  #endif
  #if defined(CPU_CLOCK_CONFIG_6)
  /* Clock configuration 6 */
  ,{
    CPU_MCG_MODE_CONFIG_6,             /* Clock generator mode */
    CPU_CLOCK_VLP_CONFIG_6,            /* Very low power mode enable/disable */
    {                                  /* MCG registers */
      CPU_MCG_C1_CONFIG_6,CPU_MCG_C2_CONFIG_6,CPU_MCG_C4_CONFIG_6,CPU_MCG_C5_CONFIG_6,CPU_MCG_C6_CONFIG_6,CPU_MCG_SC_CONFIG_6,CPU_OSC_CR_CONFIG_6,
    },
    {                                  /* SIM registers */
      CPU_SIM_SOPT1_CONFIG_6,CPU_SIM_SOPT2_CONFIG_6,CPU_SIM_CLKDIV1_CONFIG_6,
    },
    CPU_BUS_CLK_HZ_CONFIG_6            /* Bus frequency */
  }
  #endif
  #if defined(CPU_CLOCK_CONFIG_7)
  /* Clock configuration 7 */
  ,{
    CPU_MCG_MODE_CONFIG_7,             /* Clock generator mode */
    CPU_CLOCK_VLP_CONFIG_7,            /* Very low power mode enable/disable */
    {                                  /* MCG registers */
      CPU_MCG_C1_CONFIG_7,CPU_MCG_C2_CONFIG_7,CPU_MCG_C4_CONFIG_7,CPU_MCG_C5_CONFIG_7,CPU_MCG_C6_CONFIG_7,CPU_MCG_SC_CONFIG_7,CPU_OSC_CR_CONFIG_7,
    },
    {                                  /* SIM registers */
      CPU_SIM_SOPT1_CONFIG_7,CPU_SIM_SOPT2_CONFIG_7,CPU_SIM_CLKDIV1_CONFIG_7,
    },
    CPU_BUS_CLK_HZ_CONFIG_7            /* Bus frequency */
  }
  #endif
};

static const CPU_TClockGenRegs CPU_DefaultFEI = {
  CPU_DEFAULT_FEI_MCG_C1,CPU_DEFAULT_FEI_MCG_C2,CPU_DEFAULT_FEI_MCG_C4,CPU_DEFAULT_FEI_MCG_C5,CPU_DEFAULT_FEI_MCG_C6,CPU_DEFAULT_FEI_MCG_SC,CPU_DEFAULT_FEI_OSC_CR
};
static const CPU_TClockGenRegs CPU_DefaultFBI = {
  CPU_DEFAULT_FBI_MCG_C1,CPU_DEFAULT_FBI_MCG_C2,CPU_DEFAULT_FBI_MCG_C4,CPU_DEFAULT_FBI_MCG_C5,CPU_DEFAULT_FBI_MCG_C6,CPU_DEFAULT_FBI_MCG_SC,CPU_DEFAULT_FBI_OSC_CR
};
static const CPU_TClockGenRegs CPU_DefaultBLPI = {
  CPU_DEFAULT_BLPI_MCG_C1,CPU_DEFAULT_BLPI_MCG_C2,CPU_DEFAULT_BLPI_MCG_C4,CPU_DEFAULT_BLPI_MCG_C5,CPU_DEFAULT_BLPI_MCG_C6,CPU_DEFAULT_BLPI_MCG_SC,CPU_DEFAULT_BLPI_OSC_CR
};
static const CPU_TClockGenRegs CPU_DefaultFEE = {
  CPU_DEFAULT_FEE_MCG_C1,CPU_DEFAULT_FEE_MCG_C2,CPU_DEFAULT_FEE_MCG_C4,CPU_DEFAULT_FEE_MCG_C5,CPU_DEFAULT_FEE_MCG_C6,CPU_DEFAULT_FEE_MCG_SC,CPU_DEFAULT_FEE_OSC_CR
};
static const CPU_TClockGenRegs CPU_DefaultFBE = {
  CPU_DEFAULT_FBE_MCG_C1,CPU_DEFAULT_FBE_MCG_C2,CPU_DEFAULT_FBE_MCG_C4,CPU_DEFAULT_FBE_MCG_C5,CPU_DEFAULT_FBE_MCG_C6,CPU_DEFAULT_FBE_MCG_SC,CPU_DEFAULT_FBE_OSC_CR
};
static const CPU_TClockGenRegs CPU_DefaultBLPE = {
  CPU_DEFAULT_BLPE_MCG_C1,CPU_DEFAULT_BLPE_MCG_C2,CPU_DEFAULT_BLPE_MCG_C4,CPU_DEFAULT_BLPE_MCG_C5,CPU_DEFAULT_BLPE_MCG_C6,CPU_DEFAULT_BLPE_MCG_SC,CPU_DEFAULT_BLPE_OSC_CR
};
static const CPU_TClockGenRegs CPU_DefaultPBE = {
  CPU_DEFAULT_PBE_MCG_C1,CPU_DEFAULT_PBE_MCG_C2,CPU_DEFAULT_PBE_MCG_C4,CPU_DEFAULT_PBE_MCG_C5,CPU_DEFAULT_PBE_MCG_C6,CPU_DEFAULT_PBE_MCG_SC,CPU_DEFAULT_PBE_OSC_CR
};
static const CPU_TClockGenRegs CPU_DefaultPEE = {
  CPU_DEFAULT_PEE_MCG_C1,CPU_DEFAULT_PEE_MCG_C2,CPU_DEFAULT_PEE_MCG_C4,CPU_DEFAULT_PEE_MCG_C5,CPU_DEFAULT_PEE_MCG_C6,CPU_DEFAULT_PEE_MCG_SC,CPU_DEFAULT_PEE_OSC_CR
};

static const CPU_TClockGenRegs *const CPU_ClockGenModeRegs[CPU_MCG_MODES] = {
  &CPU_DefaultFEI,
  &CPU_DefaultFBI,
  &CPU_DefaultBLPI,
  &CPU_DefaultFEE,
  &CPU_DefaultFBE,
  &CPU_DefaultBLPE,
  &CPU_DefaultPBE,
  &CPU_DefaultPEE
};

/*
** ===========================================================================
** The array of clock frequencies in configured clock configurations.
** ===========================================================================
*/
/*! The array of clock configurations (frequencies) configured in configured clock configurations of the CPU component. */
const TCpuClockConfiguration PE_CpuClockConfigurations[CPU_CLOCK_CONFIG_NUMBER] = {
  /* Clock configuration 0 */
  {
    CPU_CORE_CLK_HZ_CONFIG_0,          /*!< Core clock frequency in clock configuration 0 */
    CPU_BUS_CLK_HZ_CONFIG_0,           /*!< Bus clock frequency in clock configuration 0 */
    CPU_FLEXBUS_CLK_HZ_CONFIG_0,       /*!< Flexbus clock frequency in clock configuration 0 */
    CPU_FLASH_CLK_HZ_CONFIG_0,         /*!< FLASH clock frequency in clock configuration 0 */
    CPU_USB_CLK_HZ_CONFIG_0,           /*!< USB clock frequency in clock configuration 0 */
    CPU_PLL_FLL_CLK_HZ_CONFIG_0,       /*!< PLL/FLL clock frequency in clock configuration 0 */
    CPU_MCGIR_CLK_HZ_CONFIG_0,         /*!< MCG internal reference clock frequency in clock configuration 0 */
    CPU_OSCER_CLK_HZ_CONFIG_0,         /*!< System OSC external reference clock frequency in clock configuration 0 */
    CPU_ERCLK32K_CLK_HZ_CONFIG_0,      /*!< External reference clock 32k frequency in clock configuration 0 */
    CPU_MCGFF_CLK_HZ_CONFIG_0          /*!< MCG fixed frequency clock */
  },
  /* Clock configuration 1 */
  {
    CPU_CORE_CLK_HZ_CONFIG_1,          /*!< Core clock frequency in clock configuration 1 */
    CPU_BUS_CLK_HZ_CONFIG_1,           /*!< Bus clock frequency in clock configuration 1 */
    CPU_FLEXBUS_CLK_HZ_CONFIG_1,       /*!< Flexbus clock frequency in clock configuration 1 */
    CPU_FLASH_CLK_HZ_CONFIG_1,         /*!< FLASH clock frequency in clock configuration 1 */
    CPU_USB_CLK_HZ_CONFIG_1,           /*!< USB clock frequency in clock configuration 1 */
    CPU_PLL_FLL_CLK_HZ_CONFIG_1,       /*!< PLL/FLL clock frequency in clock configuration 1 */
    CPU_MCGIR_CLK_HZ_CONFIG_1,         /*!< MCG internal reference clock frequency in clock configuration 1 */
    CPU_OSCER_CLK_HZ_CONFIG_1,         /*!< System OSC external reference clock frequency in clock configuration 1 */
    CPU_ERCLK32K_CLK_HZ_CONFIG_1,      /*!< External reference clock 32k frequency in clock configuration 1 */
    CPU_MCGFF_CLK_HZ_CONFIG_1          /*!< MCG fixed frequency clock */
  },
  /* Clock configuration 2 */
  {
    CPU_CORE_CLK_HZ_CONFIG_2,          /*!< Core clock frequency in clock configuration 2 */
    CPU_BUS_CLK_HZ_CONFIG_2,           /*!< Bus clock frequency in clock configuration 2 */
    CPU_FLEXBUS_CLK_HZ_CONFIG_2,       /*!< Flexbus clock frequency in clock configuration 2 */
    CPU_FLASH_CLK_HZ_CONFIG_2,         /*!< FLASH clock frequency in clock configuration 2 */
    CPU_USB_CLK_HZ_CONFIG_2,           /*!< USB clock frequency in clock configuration 2 */
    CPU_PLL_FLL_CLK_HZ_CONFIG_2,       /*!< PLL/FLL clock frequency in clock configuration 2 */
    CPU_MCGIR_CLK_HZ_CONFIG_2,         /*!< MCG internal reference clock frequency in clock configuration 2 */
    CPU_OSCER_CLK_HZ_CONFIG_2,         /*!< System OSC external reference clock frequency in clock configuration 2 */
    CPU_ERCLK32K_CLK_HZ_CONFIG_2,      /*!< External reference clock 32k frequency in clock configuration 2 */
    CPU_MCGFF_CLK_HZ_CONFIG_2          /*!< MCG fixed frequency clock */
  }
};

/* Global variables */
LDD_TClockConfiguration ClockConfigurationID = CPU_CLOCK_CONFIG_0; /* Active clock configuration */

/* Local function prototypes */
LDD_TError CPU_MCGAutoTrim(uint8_t ClockSelect);
LDD_TError CPU_SetClockConfiguration(LDD_TClockConfiguration ModeID);
uint8_t    CPU_GetClockConfiguration(void);
LDD_TError CPU_SetOperationMode(LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr);

void       PE_low_level_init(void);
void       CPU_SetClockConfigGenMode(LDD_TClockConfiguration ConfigID);
CPU_TClockGenMode CPU_GetClockGenMode(void);

/*
** ===================================================================
**     Method      :  Cpu_LDD_SetClockConfiguration (component MK64FN1M0LQ12)
*/
/*!
**     @brief
**         Changes the clock configuration of all LDD components in a 
**         project.
**     @param
**       ClockConfiguration - New CPU clock configuration changed by CPU SetClockConfiguration method.
*/
/* ===================================================================*/
void LDD_SetClockConfiguration(LDD_TClockConfiguration ClockConfiguration)
{
  (void)ClockConfiguration;            /*!< Parameter is not used, suppress unused argument warning */
}

/*
** ===================================================================
**     Method      :  CPU_MCGAutoTrim (component MK64FN1M0LQ12)
*/
/*!
**     @brief
**         This method uses MCG auto trim feature to trim internal
**         reference clock. This method can be used only in a clock
**         configuration which derives its bus clock from external
**         reference clock ([MCG mode] must be one of the following
**         modes - FEE, FBE, BLPE, PEE, PBE) and if value of [Bus clock]
**         is in the range <8; 16>MHz.
**         The slow internal reference clock is trimmed to the value
**         selected by [Slow internal reference clock [kHz]] property. 
**         The fast internal reference clock will be trimmed to value
**         4MHz.
**     @param
**         ClockSelect     - Selects which internal
**                           reference clock will be trimmed.
**                           0 ... slow (32kHz) internal reference clock
**                           will be trimmed
**                           > 0 ... fast (4MHz) internal reference
**                           clock will be trimmed
**     @return
**                         - Error code
**                           ERR_OK - OK
**                           ERR_SPEED - The method does not work in the
**                           active clock configuration.
**                           ERR_FAILED - Autotrim process failed.
*/
/* ===================================================================*/
LDD_TError CPU_MCGAutoTrim(uint8_t ClockSelect)
{
  uint16_t CompareValue;               /* Autotrim compare value expected count */
  uint16_t BusClockMHz = (uint16_t)((uint32_t)(CPU_ClockConfigDescriptors[ClockConfigurationID].BusClock) /1000000UL); /* Bus clock in MHz */

  /* Calculate compare value */
  if (((CPU_ClockConfigDescriptors[ClockConfigurationID].Mode & (CPU_CLOCK_EXTERNAL_CLOCK_MASK | CPU_CLOCK_EXTERNAL_CRYSTAL_MASK)) != 0) && (BusClockMHz >= 8U) && (BusClockMHz <= 16U)) {
    if (ClockSelect == 0x00U) {
      CompareValue = (uint16_t)(21000 * BusClockMHz / CPU_INT_SLOW_CLK_HZ); /* Slow internal reference clock */
    } else {
      CompareValue = (uint16_t)(672U * BusClockMHz); /* Fast internal reference clock */
    }
  } else {
    return ERR_SPEED;                  /* MCU has to be clocked from external clock and has to have bus clock in allowed range */
  }
  MCG_ATCVH = (uint8_t)(CompareValue >> 8U); /* Set compare value high half */
  MCG_ATCVL = (uint8_t)(CompareValue & 255U); /* Set compare value low half */
  if (ClockSelect == 0x00U) {
    /* MCG_SC: ATME=1,ATMS=0,LOCS0=0 */
    MCG_SC = (uint8_t)((MCG_SC & (uint8_t)~(uint8_t)(
              MCG_SC_ATMS_MASK |
              MCG_SC_LOCS0_MASK
             )) | (uint8_t)(
              MCG_SC_ATME_MASK
             ));                       /* Start trimming of the slow internal reference clock */
  } else {
    /* MCG_SC: ATME=1,ATMS=1,LOCS0=0 */
    MCG_SC = (uint8_t)((MCG_SC & (uint8_t)~(uint8_t)(
              MCG_SC_LOCS0_MASK
             )) | (uint8_t)(
              MCG_SC_ATME_MASK |
              MCG_SC_ATMS_MASK
             ));                       /* Start trimming of the fast internal reference clock */
  }
  while ((MCG_SC & MCG_SC_ATME_MASK) != 0x00U) { /* Wait until autotrim completes */
  }
  if ((MCG_SC & MCG_SC_ATMF_MASK) == 0x00U) {
    return ERR_OK;                     /* Trim operation completed successfully */
  } else {
    return ERR_FAILED;                 /* Trim operation failed */
  }
}

CPU_TClockGenMode CPU_GetClockGenMode(void)
{
  switch (MCG_C1  & MCG_C1_CLKS_MASK) {
    case  0x00U:
      /* Output of FLL or PLL is selected */
      if ((MCG_C6 & MCG_C6_PLLS_MASK) == 0x00U) {
        /* Output of FLL is selected */
        if ((MCG_C1 & MCG_C1_IREFS_MASK) == 0x00U) {
          /* External reference clock is selected */
          return CPU_MCG_MODE_FEE;
        } else {
          /* Internal reference clock is selected */
          return CPU_MCG_MODE_FEI;
        }
      } else {
        /* Output of FLL is selected */
	      return CPU_MCG_MODE_PEE;
	    }  
    case 0x40U:
      /* Internal reference clock is selected */
      if ((MCG_C2 & MCG_C2_LP_MASK) == 0x00U) {
        /* Low power mode is disabled */
        return CPU_MCG_MODE_FBI;
      } else {
        /* Low power mode is enabled */
        return CPU_MCG_MODE_BLPI;
      }
    case 0x80U:
      /* External reference clock is selected */
      if ((MCG_C6 & MCG_C6_PLLS_MASK) == 0x00U) {
        /* FLL or PLL is selected */
        if ((MCG_C2 & MCG_C2_LP_MASK) == 0x00U) {
          /* FLL is selected */
          return CPU_MCG_MODE_FBE;
        } else {
          /* Low power mode is enabled */
          return CPU_MCG_MODE_BLPE;
        }
      } else {
        /* PLL is selected */
        return CPU_MCG_MODE_PBE;
      }
    default:
      return (CPU_TClockGenMode)0x00U;
  }
}

void CPU_SetClockConfigGenMode(LDD_TClockConfiguration ConfigID)
{
  CPU_TClockGenMode NextMode;
  CPU_TClockGenRegs NextModeRegs;
  CPU_TClockGenMode TargetMode = CPU_ClockConfigDescriptors[ConfigID].Mode;
  
  /* External clock source pin routing */
  if ((TargetMode & (CPU_CLOCK_EXTERNAL_CLOCK_MASK | CPU_CLOCK_EXTERNAL_CRYSTAL_MASK)) != 0) { /* Is external clock source used in targeted clock configuration? */
    /* If yes, initialize the EXTAL pin routing */
    SIM_SCGC5 |= (uint16_t)SIM_SCGC5_PORTA_MASK; /* Enable EXTAL/XTAL pins clock gate */
    /* PORTA_PCR18: MUX=0 */
    PORTA_PCR18 &= (uint32_t)~(uint32_t)0x0700;
    if ((TargetMode & CPU_CLOCK_EXTERNAL_CRYSTAL_MASK) != 0) { /* Is external crystal/resonator used in targeted clock configuration? */
      /* If yes, initialize also XTAL pin routing */
      /* PORTA_PCR19: MUX=0 */
      PORTA_PCR19 &= (uint32_t)~(uint32_t)0x0700;
    }
  }
  
  if ((MCG_SC & MCG_SC_FCRDIV_MASK) != CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_SC_value) { /* Check if it is necessary to update Fast Clock Internal Reference Divider */ 
    if ((MCG_C2 & MCG_C2_IRCS_MASK) == 0x00U) {
      MCG_SC = (MCG_SC & (uint8_t)(~(MCG_SC_FCRDIV_MASK))) | CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_SC_value;
    } else {
      if ((MCG_C1 & (MCG_C1_IREFS_MASK || MCG_C1_IRCLKEN_MASK)) != 0x00U) { /* Is internal reference clock active? */      
        MCG_C2 &= (uint8_t)(~(MCG_C2_IRCS_MASK)); /* Disable the fast internal clock */
        while((MCG_S & MCG_S_IRCST_MASK) != 0x00U) { /* Check that the source internal reference clock is slow clock. */
        }
        MCG_SC = (MCG_SC & (uint8_t)(~(MCG_SC_FCRDIV_MASK))) | CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_SC_value;    
        MCG_C2 |= MCG_C2_IRCS_MASK;    /* Re-enable the fast internal clock */
        while((MCG_S & MCG_S_IRCST_MASK) == 0x00U) { /* Check that the source internal reference clock is fast clock. */
        }
      } else {
        MCG_C2 &= (uint8_t)(~(MCG_C2_IRCS_MASK)); /* Disable the fast internal clock */
        MCG_SC = (MCG_SC & (uint8_t)(~(MCG_SC_FCRDIV_MASK))) | CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_SC_value;    
        MCG_C2 |= MCG_C2_IRCS_MASK;    /* Re-enable the fast internal clock */
      }
    }
  }      
  NextMode = CPU_GetClockGenMode(); /* Identify the currently active MCG mode */
  do {
    NextMode = ClockGenModeMatrix[NextMode & CPU_MCG_MODE_INDEX_MASK][TargetMode & CPU_MCG_MODE_INDEX_MASK];
    if (NextMode == (TargetMode & CPU_MCG_MODE_INDEX_MASK)) {
      NextModeRegs = CPU_ClockConfigDescriptors[ConfigID].GenRegs;
    } else {
      NextModeRegs = *CPU_ClockGenModeRegs[NextMode & CPU_MCG_MODE_INDEX_MASK];
    }
    switch (NextMode & CPU_MCG_MODE_INDEX_MASK) {
      case CPU_MCG_MODE_FEI:
      case CPU_MCG_MODE_FBI:
        MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
        while((MCG_S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
        }
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
        MCG_C4 = ((NextModeRegs.MCG_C4_value) & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG_C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */      	
        if (TargetMode & CPU_CLOCK_RTC_OSC_MASK) {
          MCG_C7 = MCG_C7_OSCSEL(1);   /* Select RTC oscillator as MCG clock source */
        } else {
          MCG_C7 = 0;                  /* Select system oscillator as MCG clock source */
        }
        MCG_C5 = NextModeRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
        if (TargetMode & CPU_CLOCK_PLL_MASK) {
          MCG_C5 |= MCG_C5_PLLCLKEN0_MASK;
        }
        MCG_C6 = NextModeRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
        break;
      case CPU_MCG_MODE_BLPI:
        MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
        while((MCG_S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
        }
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
        if (TargetMode & CPU_CLOCK_FAST_MASK) {
          while((MCG_S & MCG_S_IRCST_MASK) == 0x00U) { /* Check that the fast external reference clock is selected. */
      	  }
      	}      	
        break;
      case CPU_MCG_MODE_FEE:
      case CPU_MCG_MODE_FBE:
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */      	
        if (TargetMode & CPU_CLOCK_RTC_OSC_MASK) {
          MCG_C7 = MCG_C7_OSCSEL(1);   /* Select RTC oscillator as MCG clock source */
        } else {
          MCG_C7 = 0;                  /* Select system oscillator as MCG clock source */
        }
        MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
        if ((TargetMode & CPU_CLOCK_EXTERNAL_CRYSTAL_MASK) != 0) {
          while((MCG_S & MCG_S_OSCINIT0_MASK) == 0x00U) { /* Check that the oscillator is running */
          }
        }
        while((MCG_S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
        }
        MCG_C4 = ((NextModeRegs.MCG_C4_value) & (uint8_t)(~(MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK))) | (MCG_C4 & (MCG_C4_FCTRIM_MASK | MCG_C4_SCFTRIM_MASK)); /* Set C4 (FLL output; trim values not changed) */
        MCG_C5 = NextModeRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
        if (TargetMode & CPU_CLOCK_PLL_MASK) {
          MCG_C5 |= MCG_C5_PLLCLKEN0_MASK;
        }
        MCG_C6 = NextModeRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
        break;
      case CPU_MCG_MODE_BLPE:
        MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */      	
        if (TargetMode & CPU_CLOCK_RTC_OSC_MASK) {
          MCG_C7 = MCG_C7_OSCSEL(1);   /* Select RTC oscillator as MCG clock source */
        } else {
          MCG_C7 = 0;                  /* Select system oscillator as MCG clock source */
        }
        if ((TargetMode & CPU_CLOCK_EXTERNAL_CRYSTAL_MASK) != 0) {
          while((MCG_S & MCG_S_OSCINIT0_MASK) == 0x00U) { /* Check that the oscillator is running */
          }
        }
        break;
      case CPU_MCG_MODE_PEE:
      case CPU_MCG_MODE_PBE:
        OSC_CR = NextModeRegs.OSC_CR_value; /* Set OSC_CR (OSCERCLK enable, oscillator capacitor load) */
        MCG_C7 = 0;                    /* Select system oscillator as MCG clock source */
        MCG_C1 = NextModeRegs.MCG_C1_value; /* Set C1 (clock source selection, FLL ext. reference divider, int. reference enable etc.) */
        MCG_C2 = ((NextModeRegs.MCG_C2_value) & (uint8_t)(~(MCG_C2_FCFTRIM_MASK))) | (MCG_C2 & MCG_C2_FCFTRIM_MASK); /* Set C2 (freq. range, ext. and int. reference selection etc.; trim values not changed) */
        if ((TargetMode & CPU_MCG_MODE_INDEX_MASK) == CPU_MCG_MODE_PEE) {
          MCG_C5 = CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
          MCG_C6 = CPU_ClockConfigDescriptors[ConfigID].GenRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
        } else {
          MCG_C5 = NextModeRegs.MCG_C5_value; /* Set C5 (PLL settings, PLL reference divider etc.) */
          MCG_C6 = NextModeRegs.MCG_C6_value; /* Set C6 (PLL select, VCO divider etc.) */
        }
        while((MCG_S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until PLL is locked*/
        }
        break;
      default:
        break;            
    }
    switch (NextMode) {
      case CPU_MCG_MODE_FEI:
      case CPU_MCG_MODE_FEE:
        while((MCG_S & 0x0CU) != 0x00U) { /* Wait until output of the FLL is selected */
        }
        break;
      case CPU_MCG_MODE_FBI:
      case CPU_MCG_MODE_BLPI:
        while((MCG_S & 0x0CU) != 0x04U) { /* Wait until internal reference clock is selected as MCG output */
        }
        break;
      case CPU_MCG_MODE_FBE:
      case CPU_MCG_MODE_BLPE:
      case CPU_MCG_MODE_PBE:
        while((MCG_S & 0x0CU) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
        }
        break;
      case CPU_MCG_MODE_PEE:
        while((MCG_S & 0x0CU) != 0x0CU) { /* Wait until output of the FLL is selected */
        }
        break;
    }
      } while (NextMode != (TargetMode & CPU_MCG_MODE_INDEX_MASK)); /* Loop until the target MCG mode is set */
    /* SIM_CLKDIV2: USBDIV=1,USBFRAC=0 */
    SIM_CLKDIV2 = (uint32_t)0x09UL; /* Update USB clock prescalers */
}

/*
** ===================================================================
**     Method      :  CPU_SetClockConfiguration (component MK64FN1M0LQ12)
*/
/*!
**     @brief
**         Calling of this method will cause the clock configuration
**         change and reconfiguration of all components according to
**         the requested clock configuration setting.
**     @param
**         ModeID          - Clock configuration identifier
**     @return
**                         - ERR_OK - OK.
**                           ERR_RANGE - Mode parameter out of range
*/
/* ===================================================================*/
LDD_TError CPU_SetClockConfiguration(LDD_TClockConfiguration ModeID)
{
  if (ModeID > (CPU_CLOCK_CONFIG_NUMBER - 1U)) {
    return ERR_RANGE;
  }
  
  if (SMC_PMSTAT == 0x04U) {           /* Test if in VLPR mode */
    /* SMC_PMCTRL: LPWUI=0,RUNM=0,??=0,STOPA=0,STOPM=0 */
    SMC_PMCTRL = (SMC_PMCTRL_RUNM(0x00) | SMC_PMCTRL_STOPM(0x00)); /* Disable very low power mode */
    while((PMC_REGSC & PMC_REGSC_REGONS_MASK) == 0x00U) { /* Wait until the regulator is in run regulation */
    }
    while(SMC_PMSTAT == 0x04U) {       /* Wait until the system is back in RUN mode */
    }
  }
  /* SIM_CLKDIV1: OUTDIV2&=~1,OUTDIV2|=1,OUTDIV3&=~4,OUTDIV3|=4,OUTDIV4&=~4,OUTDIV4|=4,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  SIM_CLKDIV1 = (uint32_t)0x01440000;  /* Set the system prescalers to safe value */
  switch (ModeID) {
  #if defined(CPU_CLOCK_CONFIG_0)
    case CPU_CLOCK_CONFIG_0:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_0);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_0) */
  #if defined(CPU_CLOCK_CONFIG_1)
    case CPU_CLOCK_CONFIG_1:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_1);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_1) */
  #if defined(CPU_CLOCK_CONFIG_2)
    case CPU_CLOCK_CONFIG_2:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_2);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_2) */
  #if defined(CPU_CLOCK_CONFIG_3)
    case CPU_CLOCK_CONFIG_3:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_3);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_3) */
  #if defined(CPU_CLOCK_CONFIG_4)
    case CPU_CLOCK_CONFIG_4:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_4);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_4) */
  #if defined(CPU_CLOCK_CONFIG_5)
    case CPU_CLOCK_CONFIG_5:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_5);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_5) */
  #if defined(CPU_CLOCK_CONFIG_6)
    case CPU_CLOCK_CONFIG_6:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_6);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_6) */
  #if defined(CPU_CLOCK_CONFIG_7)
    case CPU_CLOCK_CONFIG_7:
      CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_7);
      break;
  #endif /* defined(CPU_CLOCK_CONFIG_7) */
    default:
      break;
  }
  SIM_CLKDIV1 = (uint32_t)CPU_ClockConfigDescriptors[ModeID].SysRegs.SIM_CLKDIV1_value; /* Update system prescalers */
  SIM_SOPT1 = (uint32_t)((SIM_SOPT1 & (uint32_t)~(uint32_t)SIM_SOPT1_OSC32KSEL_MASK) | (uint32_t)CPU_ClockConfigDescriptors[ModeID].SysRegs.SIM_SOPT1_value); /* Update 32 kHz oscillator clock source (ERCLK32K) */
  SIM_SOPT2 = (uint32_t)((SIM_SOPT2 & (uint32_t)~(uint32_t)SIM_SOPT2_PLLFLLSEL_MASK) | (uint32_t)CPU_ClockConfigDescriptors[ModeID].SysRegs.SIM_SOPT2_value); /* Update PLL/FLL clock select */
  LDD_SetClockConfiguration(ModeID);   /* Call all LDD components to update the clock configuration */
  ClockConfigurationID = ModeID;       /* Store clock configuration identifier */
  if ((CPU_ClockConfigDescriptors[ClockConfigurationID].LowPower & CPU_CLOCK_VLP_AUTO_ENABLE_MASK) != 0U) {
    /* SMC_PMCTRL: LPWUI=0,RUNM=2,??=0,STOPA=0,STOPM=0 */
    SMC_PMCTRL = (SMC_PMCTRL_RUNM(0x02) | SMC_PMCTRL_STOPM(0x00)); /* Enable very low power mode */
    if ((CPU_ClockConfigDescriptors[ClockConfigurationID].LowPower & CPU_CLOCK_VLP_WAKEUP_MASK) != 0U) {
      /* SMC_PMCTRL: LPWUI=1 */
      SMC_PMCTRL |= SMC_PMCTRL_LPWUI_MASK; /* Enable exits to Normal RUN mode on an interrupt */
    }
    while(SMC_PMSTAT != 0x04U) {       /* Wait until in the Very Low Power run mode */
    }
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  CPU_GetClockConfiguration (component MK64FN1M0LQ12)
*/
/*!
**     @brief
**         Returns the active clock configuration identifier. The
**         method is automatically enabled if more than one clock
**         configuration is enabled in the component.
**     @return
**                         - Active clock configuration identifier
*/
/* ===================================================================*/
LDD_TClockConfiguration CPU_GetClockConfiguration(void)
{
#if CPU_CLOCK_CONFIG_NUMBER > 1
  return ClockConfigurationID;         /* Return the actual clock configuration identifier */
#else
  return CPU_CLOCK_CONFIG_0;           /* Return the actual clock configuration identifier */
#endif
}

/*
** ===================================================================
**     Method      :  CPU_SetOperationMode (component MK64FN1M0LQ12)
*/
/*!
**     @brief
**         This method requests to change the component's operation
**         mode (RUN, WAIT, SLEEP, STOP). The target operation mode
**         will be entered immediately. 
**         See [Operation mode settings] for further details of the
**         operation modes mapping to low power modes of the cpu.
**     @param
**         OperationMode   - Requested driver
**                           operation mode
**     @param
**         ModeChangeCallback - Callback to
**                           notify the upper layer once a mode has been
**                           changed. Parameter is ignored, only for
**                           compatibility of API with other components.
**     @param
**         ModeChangeCallbackParamPtr 
**                           - Pointer to callback parameter to notify
**                           the upper layer once a mode has been
**                           changed. Parameter is ignored, only for
**                           compatibility of API with other components.
**     @return
**                         - Error code
**                           ERR_OK - OK
**                           ERR_PARAM_MODE - Invalid operation mode
*/
/* ===================================================================*/
LDD_TError CPU_SetOperationMode(LDD_TDriverOperationMode OperationMode, LDD_TCallback ModeChangeCallback, LDD_TCallbackParam *ModeChangeCallbackParamPtr)
{
  (void) ModeChangeCallback;           /* Parameter is not used, suppress unused argument warning */
  (void) ModeChangeCallbackParamPtr;   /* Parameter is not used, suppress unused argument warning */
  
    switch (OperationMode) {
    case DOM_RUN:
      /* SCB_SCR: SLEEPDEEP=0,SLEEPONEXIT=0 */
      SCB_SCR &= (uint32_t)~(uint32_t)(
                  SCB_SCR_SLEEPDEEP_MASK |
                  SCB_SCR_SLEEPONEXIT_MASK
                 );                    /* Set RUN or VLPR mode */
      if ((CPU_ClockConfigDescriptors[ClockConfigurationID].Mode & CPU_MCG_MODE_INDEX_MASK) == CPU_MCG_MODE_PEE) {
        if ((MCG_S & MCG_S_CLKST_MASK) != MCG_S_CLKST(3)) { /* If in PBE mode, switch to PEE. PEE to PBE transition was caused by wakeup from low power mode. */
          /* MCG_C1: CLKS=0,IREFS=0 */
          MCG_C1 &= (uint8_t)~(uint8_t)((MCG_C1_CLKS(0x03) | MCG_C1_IREFS_MASK)); /* Switch back to the PEE mode */
          while( (MCG_S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait for PLL lock */
          }
        }
      }
      break;
    case DOM_WAIT:
      /* SCB_SCR: SLEEPDEEP=0 */
      SCB_SCR &= (uint32_t)~(uint32_t)(SCB_SCR_SLEEPDEEP_MASK); /* WAIT or VLPW mode can be entered after WFI instruction call */
  #if CPU_LOW_POWER_WAIT_SLEEP_ON_EXIT
      /* SCB_SCR: SLEEPONEXIT=1 */
      SCB_SCR |= SCB_SCR_SLEEPONEXIT_MASK; /* Enter wait state on ISR exit */
  #else /* CPU_LOW_POWER_WAIT_SLEEP_ON_EXIT */
      /* SCB_SCR: SLEEPONEXIT=0 */
      SCB_SCR &= (uint32_t)~(uint32_t)(SCB_SCR_SLEEPONEXIT_MASK); /* Do not enter wait state on ISR exit */
  #endif /* CPU_LOW_POWER_WAIT_SLEEP_ON_EXIT */
      PE_WFI();                        /* Enter WAIT or VLPW state */
      break;
    case DOM_SLEEP:
      /* SCB_SCR: SLEEPDEEP=1 */
      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK; /* STOP VLPS or VLLSx mode can be entered after WFI instruction call */
      /* SMC_PMCTRL: STOPM=0 */
      SMC_PMCTRL &= (uint8_t)~(uint8_t)(SMC_PMCTRL_STOPM(0x07)); /* Set normal STOP mode */
      (void)(SMC_PMCTRL == 0U);        /* Dummy read of SMC_PMCTRL to ensure the register is written before entering low power mode */
  #if CPU_LOW_POWER_SLEEP_SLEEP_ON_EXIT
      /* SCB_SCR: SLEEPONEXIT=1 */
      SCB_SCR |= SCB_SCR_SLEEPONEXIT_MASK; /* Enter stop state on ISR exit */
  #else /* CPU_LOW_POWER_SLEEP_SLEEP_ON_EXIT */
      /* SCB_SCR: SLEEPONEXIT=0 */
      SCB_SCR &= (uint32_t)~(uint32_t)(SCB_SCR_SLEEPONEXIT_MASK); /* Do not enter stop state on ISR exit */
  #endif /* CPU_LOW_POWER_SLEEP_SLEEP_ON_EXIT */
      PE_WFI();                        /* Enter STOP state */
      break;
    case DOM_STOP:
  #if CPU_LOW_POWER_STOP
      /* Clear LLWU flags */
      /* LLWU_F1: WUF7=1,WUF6=1,WUF5=1,WUF4=1,WUF3=1,WUF2=1,WUF1=1,WUF0=1 */
      LLWU_F1 = LLWU_F1_WUF7_MASK |
                LLWU_F1_WUF6_MASK |
                LLWU_F1_WUF5_MASK |
                LLWU_F1_WUF4_MASK |
                LLWU_F1_WUF3_MASK |
                LLWU_F1_WUF2_MASK |
                LLWU_F1_WUF1_MASK |
                LLWU_F1_WUF0_MASK;
      /* LLWU_F2: WUF15=1,WUF14=1,WUF13=1,WUF12=1,WUF11=1,WUF10=1,WUF9=1,WUF8=1 */
      LLWU_F2 = LLWU_F2_WUF15_MASK |
                LLWU_F2_WUF14_MASK |
                LLWU_F2_WUF13_MASK |
                LLWU_F2_WUF12_MASK |
                LLWU_F2_WUF11_MASK |
                LLWU_F2_WUF10_MASK |
                LLWU_F2_WUF9_MASK |
                LLWU_F2_WUF8_MASK;
      /* LLWU_F3: MWUF7=1,MWUF6=1,MWUF5=1,MWUF4=1,MWUF3=1,MWUF2=1,MWUF1=1,MWUF0=1 */
      LLWU_F3 = LLWU_F3_MWUF7_MASK |
                LLWU_F3_MWUF6_MASK |
                LLWU_F3_MWUF5_MASK |
                LLWU_F3_MWUF4_MASK |
                LLWU_F3_MWUF3_MASK |
                LLWU_F3_MWUF2_MASK |
                LLWU_F3_MWUF1_MASK |
                LLWU_F3_MWUF0_MASK;
      /* LLWU_FILT1: FILTF=1 */
      LLWU_FILT1 |= LLWU_FILT1_FILTF_MASK;
      /* LLWU_FILT2: FILTF=1 */
      LLWU_FILT2 |= LLWU_FILT2_FILTF_MASK;
      /* SCB_SCR: SLEEPONEXIT=0 */
      SCB_SCR &= (uint32_t)~(uint32_t)(SCB_SCR_SLEEPONEXIT_MASK); /* Do not enter stop state on ISR exit */
      /* SCB_SCR: SLEEPDEEP=1 */
      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK; /* STOP VLPS or VLLSx mode can be entered after WFI instruction call */
    #if (CPU_LOW_POWER_STOP == CPU_LOW_POWER_STOP_LLS)
      /* SMC_PMCTRL: STOPM=3 */
      SMC_PMCTRL = (uint8_t)((SMC_PMCTRL & (uint8_t)~(uint8_t)(
                    SMC_PMCTRL_STOPM(0x04)
                   )) | (uint8_t)(
                    SMC_PMCTRL_STOPM(0x03)
                   ));                 /* Set Very-low-leakage mode */
    #else  
      /* SMC_PMCTRL: STOPM=4 */
      SMC_PMCTRL = (uint8_t)((SMC_PMCTRL & (uint8_t)~(uint8_t)(
                    SMC_PMCTRL_STOPM(0x03)
                   )) | (uint8_t)(
                    SMC_PMCTRL_STOPM(0x04)
                   ));                 /* Set Very-low-leakage mode */
      #if (CPU_LOW_POWER_STOP == CPU_LOW_POWER_STOP_VLLS0)
        #if (CPU_LOW_POWER_STOP_POR_DETECT)
      /* SMC_VLLSCTRL: ??=0,??=0,PORPO=0,??=0,??=0,VLLSM=0 */
      SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x00); /* Set VLLS0 mode with POR detect enabled */
        #else /* CPU_LOW_POWER_STOP_POR_DETECT */
      /* SMC_VLLSCTRL: ??=0,??=0,PORPO=1,??=0,??=0,VLLSM=0 */
      SMC_VLLSCTRL = (SMC_VLLSCTRL_PORPO_MASK | SMC_VLLSCTRL_VLLSM(0x00)); /* Set VLLS0 mode with POR detect disabled */
        #endif /* CPU_LOW_POWER_STOP_POR_DETECT */
      #elif (CPU_LOW_POWER_STOP == CPU_LOW_POWER_STOP_VLLS3)
      /* SMC_VLLSCTRL: ??=0,??=0,PORPO=0,??=0,??=0,VLLSM=3 */
      SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x03); /* Set VLLS3 mode */
      #elif (CPU_LOW_POWER_STOP == CPU_LOW_POWER_STOP_VLLS2)
      /* SMC_VLLSCTRL: ??=0,??=0,PORPO=0,??=0,??=0,VLLSM=2 */
      SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x02); /* Set VLLS2 mode */
      #elif (CPU_LOW_POWER_STOP == CPU_LOW_POWER_STOP_VLLS1)
      /* SMC_VLLSCTRL: ??=0,??=0,PORPO=0,??=0,??=0,VLLSM=1 */
      SMC_VLLSCTRL = SMC_VLLSCTRL_VLLSM(0x01); /* Set VLLS1 mode */
      #else /* CPU_LOW_POWER_STOP == CPU_LOW_POWER_STOP_VLLS3 */
            #error Unsupported STOP low power mode
      #endif /* CPU_LOW_POWER_STOP == CPU_LOW_POWER_STOP_VLLS3 */
    #endif /* CPU_LOW_POWER_STOP == CPU_LOW_POWER_STOP_LLS */
      (void)(SMC_PMCTRL == 0U);        /* Dummy read of SMC_PMCTRL to ensure the register is written before entering low power mode */
      PE_WFI();                        /* Enter STOP state */
  #endif /* CPU_LOW_POWER_STOP */
      break;
    default:
      return ERR_PARAM_MODE;
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  __pe_initialize_hardware (component MK64FN1M0LQ12)
**
**     Description :
**         Initializes the whole system like timing, external bus, etc.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void _bsp_initialize_hardware(void)
{
    _bsp_watchdog_disable();

#if MQX_ENABLE_LOW_POWER
    /* Reset from LLWU wake up source */
    if (_lpm_get_reset_source() == MQX_RESET_SOURCE_LLWU)
    {
        PMC_REGSC |= PMC_REGSC_ACKISO_MASK;
    }
#endif
  /*** !!! Here you can place your own code before PE initialization using property "User code before PE initialization" on the build options tab. !!! ***/

  /* System clock initialization */
    
  /* SIM_CLKDIV1: OUTDIV2&=~1,OUTDIV2|=1,OUTDIV3&=~4,OUTDIV3|=4,OUTDIV4&=~4,OUTDIV4|=4,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  SIM_CLKDIV1 = (uint32_t)0x01440000;  /* Set the system prescalers to safe value */
  CPU_SetClockConfigGenMode(CPU_CLOCK_CONFIG_0);
  SIM_CLKDIV1 = (uint32_t)CPU_ClockConfigDescriptors[CPU_CLOCK_CONFIG_0].SysRegs.SIM_CLKDIV1_value; /* Update system prescalers */
  SIM_SOPT1 = (uint32_t)((SIM_SOPT1 & (uint32_t)~(uint32_t)SIM_SOPT1_OSC32KSEL_MASK) | (uint32_t)CPU_ClockConfigDescriptors[CPU_CLOCK_CONFIG_0].SysRegs.SIM_SOPT1_value); /* Update 32 kHz oscillator clock source (ERCLK32K) */
  SIM_SOPT2 = (uint32_t)((SIM_SOPT2 & (uint32_t)~(uint32_t)SIM_SOPT2_PLLFLLSEL_MASK) | (uint32_t)CPU_ClockConfigDescriptors[CPU_CLOCK_CONFIG_0].SysRegs.SIM_SOPT2_value); /* Update PLL/FLL clock select */

  /*** !!! Here you can place your own code after PE initialization using property "User code after PE initialization" on the build options tab. !!! ***/
}



/*
** ===================================================================
**     Method      :  PE_low_level_init (component MK64FN1M0MC12)
**
**     Description :
**         Initializes beans and provides common register initialization.
**         The method is called automatically as a part of the
**         application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void PE_low_level_init(void)
{
}


#endif /* PE_LDD_VERSION */


uint16_t _bsp_set_clock_configuration
(
    /* [IN] runtime clock configuration */
    const BSP_CLOCK_CONFIGURATION clock_configuration
)
{
    uint16_t    cpu_error = ERR_OK;
    uint32_t     result;

    cpu_error = CPU_SetClockConfiguration((uint8_t)clock_configuration);
    if (cpu_error != ERR_OK)    {
        return cpu_error;
    }

    /* Change frequency for system timer */
    result = hwtimer_set_freq(&systimer, BSP_SYSTIMER_SRC_CLK, BSP_ALARM_FREQUENCY);
    if (MQX_OK != result)
    {
        return ERR_FAILED;
    }

    return ERR_OK;
}


BSP_CLOCK_CONFIGURATION _bsp_get_clock_configuration
(
    void
)
{
    return (BSP_CLOCK_CONFIGURATION)CPU_GetClockConfiguration();
}


uint32_t _bsp_get_clock
(
    const BSP_CLOCK_CONFIGURATION   clock_configuration,
    const CM_CLOCK_SOURCE           clock_source
)
{
    uint32_t clock = 0;

    if (clock_configuration < BSP_CLOCK_CONFIGURATIONS)    {
        if (clock_source  < (sizeof(PE_CpuClockConfigurations[0])/sizeof(uint32_t)))  {
            clock = *(((uint32_t *)&(PE_CpuClockConfigurations[clock_configuration])) + clock_source);
        }
        /* Return low power oscillator frequency which is not in clock structure */
        else if (clock_source == CM_CLOCK_SOURCE_LPO) {
            clock = (uint32_t)1000;
        }
    }

    return clock;
}


uint16_t _bsp_osc_autotrim
(
    void
)
{
    uint16_t        CPU_Error = ERR_OK;
    /*
     * Its assumed that before auto trimming process
     * the MCG is switched to a clock configuration
     * which derives its bus clock from external reference clock
     * and (<MCG mode> is set to one of the following modes
     * FEE, FBE, BLPE, PEE, PBE) and if value of <Bus clock>
     * is in the range <8; 16>MHz.
     */

    /* Auto trim Slow internal reference clock */
    CPU_Error = CPU_MCGAutoTrim(0);
    if (CPU_Error != ERR_OK) return CPU_Error;

    /* Auto trim Fast internal reference clock */
    CPU_Error = CPU_MCGAutoTrim(1);
    if (CPU_Error != ERR_OK) return CPU_Error;

    return ERR_OK;

}
void _bsp_low_level_init(void)
{
    PE_low_level_init();
}

